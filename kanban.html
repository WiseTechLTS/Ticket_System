<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Ticket Kanban Board</title>
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0-alpha1/dist/css/bootstrap.min.css" rel="stylesheet" />
  <style>
    body {
      background-color: #f2f7f9;
      padding: 20px;
      font-family: "Helvetica Neue", Arial, sans-serif;
      color: #555;
    }
    .sticky-header {
      background: linear-gradient(135deg, #a1c4fd, #c2e9fb);
      color: #333;
      padding: 20px;
      margin-bottom: 20px;
      text-align: center;
      border-radius: 8px;
      box-shadow: 0 2px 4px rgba(0,0,0,0.1);
    }
    .status-bar-container {
      margin: 20px 0;
      display: flex;
      align-items: center;
      flex-wrap: wrap;
      gap: 20px;
      justify-content: center;
    }
    .status-bar {
      width: 300px;
      height: 25px;
    }
    .ticket-counter {
      width: 100%;
      max-width: 400px;
    }
    .kanban-board {
      display: flex;
      flex-wrap: wrap;
      gap: 15px;
    }
    .kanban-column {
      flex: 1;
      min-width: 250px;
      background: #fff;
      border-radius: 8px;
      padding: 15px;
      border: 1px solid #e0e0e0;
      min-height: 500px;
      position: relative;
      box-shadow: 0 1px 3px rgba(0,0,0,0.1);
    }
    .kanban-column h2 {
      font-size: 1.1rem;
      text-align: center;
      margin-bottom: 15px;
      color: #3d3d3d;
    }
    .ticket-card {
      background: #fff;
      border: 1px solid #e0e0e0;
      border-radius: 8px;
      padding: 10px;
      margin-bottom: 10px;
      cursor: grab;
      display: flex;
      align-items: center;
      gap: 10px;
      transition: transform 0.5s ease, opacity 0.5s ease;
    }
    .ticket-card.dragging {
      opacity: 0.5;
    }
    .kanban-column.drag-over {
      background: #f1f8e9;
      border-color: #dcedc8;
    }
    .ticket-thumbnail {
      width: 40px;
      height: 40px;
      border-radius: 50%;
      object-fit: cover;
      border: 1px solid #ccc;
    }
    @keyframes meltOff {
      0% { opacity: 1; transform: scale(1); }
      100% { opacity: 0; transform: scale(0.1); }
    }
    .melt-off {
      animation: meltOff 1s forwards;
    }
  </style>
</head>
<body>
  <div class="container-fluid">
    <header class="sticky-header">
      <h1>Ticket Kanban Board</h1>
      <p>Drag and drop tickets or let our intelligent automation progress them through our escalation workflow.</p>
    </header>
    
    <!-- Database Connection and Ticket Counter Section -->
    <div class="status-bar-container">
      <div class="progress status-bar">
        <div id="dbStatusBar" class="progress-bar bg-danger" role="progressbar" style="width: 0%;" aria-valuemin="0" aria-valuemax="100">
          Disconnected
        </div>
      </div>
      <button id="connectBtn" class="btn btn-primary">Connect to Database</button>
      <button id="disconnectBtn" class="btn btn-secondary" disabled>Disconnect</button>
      <button id="deleteSelectedBtn" class="btn btn-danger">Delete Selected</button>
      <button id="deleteAllBtn" class="btn btn-danger">Delete All</button>
      <div class="ticket-counter">
        <div class="table-responsive">
          <table class="table table-bordered table-sm">
            <thead class="table-light">
              <tr>
                <th>Active Tickets</th>
                <th>Archived Tickets</th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td id="activeCount">0</td>
                <td id="archivedCount">0</td>
              </tr>
            </tbody>
          </table>
        </div>
      </div>
    </div>

    <div class="kanban-board" id="kanbanBoard">
      <!-- Kanban Columns -->
      <div class="kanban-column" data-step="1">
        <h2>Ticket Received – Awaiting Initial Review</h2>
      </div>
      <div class="kanban-column" data-step="2">
        <h2>Under Analysis – Escalation in Progress</h2>
      </div>
      <div class="kanban-column" data-step="3">
        <h2>Actioning – In-depth Troubleshooting</h2>
      </div>
      <div class="kanban-column" data-step="4">
        <h2>Resolution – Final Verification</h2>
      </div>
      <div class="kanban-column" data-step="archived">
        <h2>Archived – Issue Resolved and Documented</h2>
      </div>
    </div>
  </div>


<script>
  document.getElementById("deleteSelectedBtn").addEventListener("click", deleteSelectedTickets);
  document.getElementById("deleteAllBtn").addEventListener("click", deleteAllTickets);

  function createTicketCard(ticket) {
    const card = document.createElement("div");
    card.className = "ticket-card";
    card.draggable = true;
    card.id = `ticket-${ticket.id}`;

    const checkbox = document.createElement("input");
    checkbox.type = "checkbox";
    checkbox.className = "ticket-checkbox";
    checkbox.dataset.id = ticket.id;

    card.innerHTML = `
      <img src="${MEDIA_URL}${ticket.image}" class="ticket-thumbnail">
      <div>
        <strong>Ticket #${ticket.id}</strong><br>
        <small>Issue: ${ticket.issue || "N/A"}</small><br>
        <small>Priority: ${formatPriority(ticket.priority)}</small>
      </div>
    `;
    card.prepend(checkbox);
    card.addEventListener("dragstart", handleDragStart);
    card.addEventListener("dragend", handleDragEnd);
    return card;
  }

  function deleteSelectedTickets() {
    const selectedTickets = document.querySelectorAll(".ticket-checkbox:checked");
    selectedTickets.forEach(checkbox => {
      const ticketId = checkbox.dataset.id;
      removeTicket(ticketId);
    });
    updateTicketCounters();
  }

  function deleteAllTickets() {
    if (confirm("Are you sure you want to delete all tickets?")) {
      allTickets.length = 0;
      document.querySelectorAll(".ticket-card").forEach(card => card.remove());
      updateTicketCounters();
    }
  }

  function removeTicket(ticketId) {
    const index = allTickets.findIndex(ticket => ticket.id.toString() === ticketId);
    if (index > -1) {
      allTickets.splice(index, 1);
      document.getElementById(`ticket-${ticketId}`).remove();
      localStorage.removeItem(`ticket-${ticketId}`);
    }
  }
</script>
  <script>
    const API_URL = "http://10.10.10.1:8000/api/ticketing/all/";
    const allTickets = []; // Stores tickets in memory
    const ticketTimers = {}; // Stores per-ticket timer IDs
    const escalationOrder = ["1", "2", "3", "4", "archived"];
    let dbConnected = false;

    const columnTitles = {
      "1": "Ticket Received – Awaiting Initial Review",
      "2": "Under Analysis – Escalation in Progress",
      "3": "Actioning – In-depth Troubleshooting",
      "4": "Resolution – Final Verification",
      "archived": "Archived – Issue Resolved and Documented"
    };

    const dbStatusBar = document.getElementById('dbStatusBar');
    const connectBtn = document.getElementById('connectBtn');
    const disconnectBtn = document.getElementById('disconnectBtn');
    const activeCountEl = document.getElementById('activeCount');
    const archivedCountEl = document.getElementById('archivedCount');

    connectBtn.addEventListener('click', connectDatabase);
    disconnectBtn.addEventListener('click', disconnectDatabase);

    function connectDatabase() {
      connectBtn.disabled = true;
      disconnectBtn.disabled = true;
      dbStatusBar.innerText = "Connecting...";
      dbStatusBar.classList.remove('bg-danger', 'bg-success');
      dbStatusBar.classList.add('bg-info');
      dbStatusBar.style.width = "50%";

      setTimeout(() => {
        dbConnected = true;
        dbStatusBar.innerText = "Connected";
        dbStatusBar.classList.remove('bg-info');
        dbStatusBar.classList.add('bg-success');
        dbStatusBar.style.width = "100%";
        connectBtn.disabled = true;
        disconnectBtn.disabled = false;
        console.log("Database connection established.");
        fetchTickets();
      }, 2000);
    }

    function disconnectDatabase() {
      disconnectBtn.disabled = true;
      dbStatusBar.innerText = "Disconnecting...";
      dbStatusBar.classList.remove('bg-success', 'bg-info');
      dbStatusBar.classList.add('bg-warning');
      dbStatusBar.style.width = "50%";

      // Stop all ticket timers and any ongoing escalation processes.
      clearAllTicketTimers();

      setTimeout(() => {
        dbConnected = false;
        dbStatusBar.innerText = "Disconnected";
        dbStatusBar.classList.remove('bg-warning');
        dbStatusBar.classList.add('bg-danger');
        dbStatusBar.style.width = "0%";
        connectBtn.disabled = false;
        disconnectBtn.disabled = true;
        console.log("Database connection terminated.");
      }, 2000);
    }

    function clearAllTicketTimers() {
      for (const ticketId in ticketTimers) {
        clearTimeout(ticketTimers[ticketId]);
      }
      // Reset the timers object.
      for (const key in ticketTimers) { delete ticketTimers[key]; }
    }

    async function fetchTickets() {
      try {
        const response = await fetch(API_URL);
        if (!response.ok) {
          throw new Error(`HTTP error! Status: ${response.status}`);
        }
        const data = await response.json();
        data.forEach((ticket, index) => {
          const status = localStorage.getItem(`ticket-${ticket.id}`) || "1";
          ticket.status = status;
          allTickets.push(ticket);
          // Schedule each ticket's auto-escalation with an initial offset.
          setTimeout(() => {
            startEscalationTimer(ticket);
          }, index * 1000);
        });
        renderTickets();
        updateTicketCounters();
      } catch (error) {
        console.error("Error fetching ticket data:", error);
      }
    }

    function renderTickets() {
      document.querySelectorAll('.kanban-column').forEach(column => {
        const step = column.getAttribute('data-step');
        column.innerHTML = `<h2>${columnTitles[step]}</h2>`;
      });
      allTickets.forEach(ticket => {
        const column = document.querySelector(`.kanban-column[data-step="${ticket.status}"]`);
        if (column) {
          const card = createTicketCard(ticket);
          column.appendChild(card);
        }
      });
      updateTicketCounters();
    }

    function createTicketCard(ticket) {
      const card = document.createElement("div");
      card.className = "ticket-card";
      card.draggable = true;
      card.id = `ticket-${ticket.id}`;
      const MEDIA_URL = "http://10.10.10.1:8000";
      const thumbnailSrc = ticket.image || "http://10.10.10.1:8000/api/ticketing/all/";
      card.innerHTML = `
        <img src="${MEDIA_URL}${thumbnailSrc}" alt="Ticket Thumbnail" class="ticket-thumbnail">
        <div>
          <strong>Ticket #${ticket.id}</strong><br>
          <small>Issue: ${ticket.issue || "N/A"}</small><br>
          <small>Priority: ${formatPriority(ticket.priority)}</small>
        </div>
      `;
      card.addEventListener("dragstart", handleDragStart);
      card.addEventListener("dragend", handleDragEnd);
      return card;
    }

    function formatPriority(priority) {
      let priorityText = "N/A";
      if (typeof priority === "number") {
        const map = { 1: "Low", 2: "Medium", 3: "High" };
        priorityText = map[priority] || "Unknown";
      } else if (typeof priority === "string") {
        priorityText = priority.charAt(0).toUpperCase() + priority.slice(1);
      }
      return priorityText;
    }

    function startEscalationTimer(ticket) {
      // Only schedule if still connected and ticket isn't archived.
      if (!dbConnected || ticket.status === "archived") return;
      
      const escalationIndex = escalationOrder.indexOf(ticket.status);
      if (escalationIndex !== -1 && escalationIndex < escalationOrder.length - 1) {
        const nextStatus = escalationOrder[escalationIndex + 1];
        // Schedule auto-escalation with a randomized delay.
        ticketTimers[ticket.id] = setTimeout(() => {
          updateTicketStatus(ticket.id, nextStatus);
          renderTickets();
          if (ticket.status !== "archived") {
            startEscalationTimer(ticket);
          }
        }, getRandomEscalationTime());
      }
    }

    function getRandomEscalationTime() {
      return Math.floor(Math.random() * 5000) + 10000; // 10s to 15s delay
    }

    function updateTicketStatus(ticketId, newStatus) {
      const ticket = allTickets.find(t => t.id.toString() === ticketId.toString());
      if (ticket) {
        ticket.status = newStatus;
        localStorage.setItem(`ticket-${ticket.id}`, newStatus);
        console.log(`Ticket #${ticket.id} escalated to ${newStatus}`);
      }
      if (newStatus === "archived") {
        const card = document.getElementById(`ticket-${ticketId}`);
        if (card) {
          card.classList.add("melt-off");
          setTimeout(() => { card.remove(); }, 1000);
        }
      }
      updateTicketCounters();
    }

    function updateTicketCounters() {
      const activeTickets = allTickets.filter(ticket => ticket.status !== "archived").length;
      const archivedTickets = allTickets.filter(ticket => ticket.status === "archived").length;
      activeCountEl.innerText = activeTickets;
      archivedCountEl.innerText = archivedTickets;
    }

    let draggedCard = null;
    function handleDragStart(e) {
      draggedCard = this;
      this.classList.add("dragging");
      e.dataTransfer.setData("text/plain", this.id);
    }
    function handleDragEnd() {
      this.classList.remove("dragging");
      draggedCard = null;
    }

    function initializeDragAndDrop() {
      const columns = document.querySelectorAll('.kanban-column');
      columns.forEach(column => {
        column.addEventListener("dragover", handleDragOver);
        column.addEventListener("dragenter", handleDragEnter);
        column.addEventListener("dragleave", handleDragLeave);
        column.addEventListener("drop", handleDrop);
      });
    }
    function handleDragOver(e) { e.preventDefault(); }
    function handleDragEnter(e) { e.preventDefault(); this.classList.add("drag-over"); }
    function handleDragLeave() { this.classList.remove("drag-over"); }
    function handleDrop(e) {
      e.preventDefault();
      this.classList.remove("drag-over");
      const ticketId = e.dataTransfer.getData("text/plain");
      const ticketElement = document.getElementById(ticketId);
      this.appendChild(ticketElement);
      const newStatus = this.getAttribute("data-step");
      updateTicketStatus(ticketId, newStatus);
    }

    document.addEventListener("DOMContentLoaded", () => {
      initializeDragAndDrop();
    });
  </script>
  
  <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0-alpha1/dist/js/bootstrap.bundle.min.js"></script>
</body>
</html>
